官方堆里面已经实现,只需要实现几个接口就阔以快乐的使用堆

参考使用例子 https://my.oschina.net/ureyishere/blog/1573654

- head接口
```golang
type Interface interface {
	sort.Interface
	Push(x interface{}) // add x as element Len()
	Pop() interface{}   // remove and return element Len() - 1.
}
```

- sort.Interface接口

```golang
type Interface interface {
	// Len is the number of elements in the collection.
	Len() int
	// Less reports whether the element with
	// index i should sort before the element with index j.
	Less(i, j int) bool
	// Swap swaps the elements with indexes i and j.
	Swap(i, j int)
}
```  

## 创建定时器任务信息

```golang
type element struct {
	TaskId    string
	Expire    time.Time
	...
}

type eleHeap []*element
```

## 实现接口

```golang
func (h eleHeap) Len() int           { return len(h) }
func (h eleHeap) Less(i, j int) bool { return h[i].Expire.Before(h[j].Expire) }
func (h eleHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *eleHeap) Push(x interface{}) {
	// Push and Pop use pointer receivers because they modify the slice's length,
	// not just its contents.
	*h = append(*h, x.(*element))
}

func (h *eleHeap) Pop() interface{} {
	old := *h
	n := len(old)
	x := old[n-1]		// 为什么Pop是取slice最末元素？
	*h = old[0 : n-1]   // 难道Golang的堆不是最小堆吗？
	return x
}
```

## 代码部分实现

```golang
to := time.NewTimer(WaitInterval)
hp := &eleHeap{} // 定义变量
heap.Init(hp) // 堆结构初始化
for {
    select {
        case ele := <-TaskChan:
            heap.Push(hp, ele) // 入堆
            to.Reset(0)
        case <-to.C:
        for hp.Len() != 0 {
                ele, ok := heap.Pop(hp).(*element) // 出堆
                if ok {
                    if time.Now().Before(ele.Expire) {
                        heap.Push(hp, ele) // 时辰未到，再次入堆
                        to.Reset(ele.Expire.Sub(now))
                        break
                    }
                    // time expired, do task
                    ...
                }
    }
    }    }}

```

